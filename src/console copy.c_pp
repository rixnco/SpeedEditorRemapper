
#include "console.h"
#include "ansi.h"

class Console : public ANSI
{
public:
  Console() : ANSI(nullptr){};

  bool begin(Stream *io) { _stream = io; return _stream!= nullptr; }
  operator bool() { return _stream != nullptr; }
  
};

static Console _term;
static uint16_t _term_width, _term_height;
static uint16_t _cur_x;
static uint16_t _cur_x_end;
static uint16_t _cur_y;
static uint16_t _cur_y_end;

#define HISTORY_SIZE (8u)
#define COMMAND_MAX_LEN (256u)
#define CTRL_CODE_MAX_LEN (28u)

static char _buffer[HISTORY_SIZE][COMMAND_MAX_LEN+1];

static size_t _history_head;
static size_t _history_tail;
static size_t _history_count;

static char*  _cmd_ptr;
static size_t _cmd_idx;
static size_t _cmd_len;
static size_t _cmd_pos;

#define ESCAPE_MAX_LEN  (64u)
static char _escape_seq[ESCAPE_MAX_LEN];
static size_t _escape_idx;




static void process_cmd(const char* cmd);

bool console_init(Stream *io)
{
  _term.begin(io);
  _history_head = 0;
  _history_tail = 0;
  _history_count = 0;
  _cmd_idx=_history_head;
  _cmd_ptr=_buffer[_cmd_idx];
  _cmd_len=0;
  _cmd_pos=0;
 
  memclr(_buffer, HISTORY_SIZE * (COMMAND_MAX_LEN+1));

  memclr(_escape_seq, ESCAPE_MAX_LEN);
  _escape_idx = 0;


  if (!_term.getScreenSize(_term_width, _term_height))
  {
    _term.println(F("\n\n### ANSI escape codes not detected ###\n"
                    "\nThis demo requires a terminal (emulator) with ANSI escape code capabilities."
                    "\nThe terminal you are using can only do TTY."
                    "\nOn Linux 'minicom' can be used. On Windows try Putty or MobaXterm."
                    "\nExample:"
                    "\n   minicom --color=on --baudrate=115200 -D /dev/ttyACM0"
                    "\n\nUTF-8 is also required. Your should see at least one emoji here?: ðŸ› ðŸ–¥ â˜Ž â¤ â£ âœ‚ âœˆ"
                    "\n"
                    "\nSystem halted."));
  }
  _term.clearScreen();
  _term.printf(">");_term.flush();

  _term.readCursorPosition(_cur_x, _cur_y);
  _cur_x_end = _cur_x;
  _cur_y_end = _cur_y;

  return io != nullptr;
}

typedef enum { 
  CMD, 
  ESC,
  ESC_CONT,
  ESC_ERROR,
  ESC_CUR_UP,
  ESC_CUR_DOWN,
  ESC_CUR_LEFT,
  ESC_CUR_RIGHT,
  ESC_CUR_START,
  ESC_CUR_END,
} parser_mode_t;

parser_mode_t mode= CMD;

void console_process()
{
  if (!_term)
    return;

  while (_term.available())
  {
    int c = _term.read();
    switch(mode)
    {
      case ESC_CONT:
      {
        _escape_seq[_escape_idx++]= c;
        switch(c) {
          case 'A':
            mode=ESC_CUR_UP;
            break;
          case 'B':
            mode=ESC_CUR_DOWN;
            break;
          case 'C':
            mode=ESC_CUR_RIGHT;
            if(_cmd_pos<_cmd_len) 
            {
              _cmd_pos+=1;
              _term.printf("\033[C");
              _term.flush();
            } else {
              _term.printf("\007");
              _term.flush();
            }

            break;
          case 'D':
            mode=ESC_CUR_LEFT;
            if(_cmd_pos>0) 
            {
              _cmd_pos-=1;
              _term.printf(_escape_seq);
              _term.flush();
            } else {
              _term.printf(_escape_seq);
              _term.flush();
            }
            break;
          default:
            mode = ESC_ERROR;
            _term.printf(_escape_seq);
        }
        mode = CMD;
        break;
      }
      case ESC:
      { 
        _escape_seq[_escape_idx++]=c;
        if(c=='[') {
          mode = ESC_CONT;
          break;
        }
        _term.printf(_escape_seq);
        mode = CMD;  // ESC_ERROR
        // keep processing charactere
      }
      case CMD:
      {
        if(c == '\033')
        {
          memclr(_escape_seq, ESCAPE_MAX_LEN);
          _escape_idx = 0;
          _escape_seq[_escape_idx++]=c;
          mode = ESC;
          break;
        }
        if (c == '\r')
          break;
        if (c == '\n')
        {
          _term.printf("\n");
          _buffer[_cmd_idx][_cmd_len] = 0;
          if(_cmd_idx!=_history_head) memcpy(_buffer[_history_head], _buffer[_cmd_idx], _cmd_len+1);
          process_cmd(_buffer[_history_head]);
          _history_head = (_history_head+1) % HISTORY_SIZE;
          if(_history_head==_history_tail) 
          {
            _history_tail = (_history_tail+1) % HISTORY_SIZE;
          }
          _history_count+= (_history_count<HISTORY_SIZE?1:0);
          memclr(_buffer[_history_head], COMMAND_MAX_LEN+1);
          _cmd_idx = _history_head;
          _cmd_ptr=_buffer[_cmd_idx];
          _cmd_len = 0;
          _cmd_pos = 0;
          memclr(_escape_seq, ESCAPE_MAX_LEN);
          _escape_idx = 0;
          _term.printf(">");_term.flush();
          break;
        }
        if(_cmd_len<=COMMAND_MAX_LEN) 
        {
          // _term.printf("%c",c);
          // _term.flush();

          if(_cmd_pos<_cmd_len) {
            memmove(&_cmd_ptr[_cmd_pos+1],&_cmd_ptr[_cmd_pos], _cmd_len-_cmd_pos);
          }
          _cmd_ptr[_cmd_pos]=c;
          _term.printf("%c", c);
          if(_cmd_pos<_cmd_len) {
            _term.printf("\0337");  // Save cursor position;
            _term.clearLine(Console::toEnd);
            _term.flush();
            _term.printf("%s", &_cmd_ptr[_cmd_pos+1]);
            _term.printf("\0338");  // Restore cursor position;
          }
          _cmd_pos+=1;
          _cmd_len+=1;
        }
        break;
      }
        

    }
    
  }
}

static void process_cmd(const char* cmd)
{
  _term.printf("%s\n",cmd);
  return;
}
